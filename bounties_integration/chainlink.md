# Keeper + External API 
``` javacript

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
import "@chainlink/contracts/src/v0.7/KeeperCompatible.sol";
import "@chainlink/contracts/src/v0.8/ChainlinkClient.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract Counter is KeeperCompatibleInterface {
    
    Public counter variable
    
     uint public counter;


    
  
    
    uint public immutable interval;
    uint public lastTimeStamp;
    using Chainlink for Chainlink.Request;
  
    string public volume;
    
    address private oracle;
    bytes32 private jobId;
    uint256 private fee;
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;

    constructor(uint updateInterval) ERC721("MyToken", "MTK") {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;
      counter = 0;
      setPublicChainlinkToken();
      oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
      jobId = "d5270d1c311941d0b08bead21fea7747";
      fee = 0.1 * 10 ** 18; // (Varies by network and job)
       
    }

    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes32 requestId, string memory _volume, bytes calldata /* performData */ ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval ) {
            lastTimeStamp = block.timestamp;
            // counter = counter + 1;
            requestVolumeData(requestId);
            fulfill(requestId,_volume );
            _safeMint('0x8d29f3f3c3fefC40fAfb88b159AA5249e9C7a746');

        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function requestVolumeData() public returns (bytes32 requestId) 
    {
        Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
        
        // Set the URL to perform the GET request on
        request.add("get", "https://api.npoint.io/c1fcf78016b48e9cd9a6");
        
       
        request.add("path", "IPFS");
        
        // Multiply the result by 1000000000000000000 to remove decimals
        int timesAmount = 10**18;
        request.addInt("times", timesAmount);
        
        // Sends the request
        return sendChainlinkRequestTo(oracle, request, fee);
    }
    
    // mint NFT function

    /**
     * Receive the response in the form of uint256
     */ 
    function fulfill(bytes32 _requestId, string memory _volume) public recordChainlinkFulfillment(_requestId)
    {
        volume = _volume;

        // Call mint nft here
    }

    
    function safeMint(address to) public onlyOwner {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
        _setTokenURI("dweb.link/ipfs/", volume);
    }


}
```
